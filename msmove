#!/usr/bin/env python3

import argparse
import base64
from calendar import month_name
import datetime
import fitz
import os
import io
import pathlib
import PIL.Image
import PIL.ImageTk
#from PIL import Image, ImageTk
import signal
import threading
import time
import tkinter as tk
from tkinter import ttk
#from tkinter import scrolledtext
from tkinter import filedialog
from tkinter import messagebox
from tkinter import *
import queue
import watchdog.events
import watchdog.observers
import yaml
import shutil

DEFAULTRENAME='statement_%Y%m'
INTERESTINGEXTENSIONS=('pdf','ps')
#from PIL import Image, ImageTk

 
class window(tk.Tk):
   def __init__(self, workqueue, srcdir, destdirtree, config):
      super().__init__()
#      ico = PIL.Image.open('file-move-icon.png')
#      photo = PIL.ImageTk.PhotoImage(ico)
      data = base64.b64decode(icon64)
      buf = io.BytesIO(data)
      ico = PIL.Image.open(buf)
      photo = PIL.ImageTk.PhotoImage(ico)

      self.wm_iconphoto(False, photo)
#self.work = workqueue  #queue to move files from callback to worklist
      self.worklock = threading.Lock()
      self.worklist = []     #list of files that we are working with
      self.worklistpos = 0  #starts from 1 index in worklist
      self.srcdir = srcdir
      self.destdirtree = destdirtree
      self.endqueue = False
      self.config = config
      self.pattnamevar = tk.StringVar()
      self.protocol("WM_DELETE_WINDOW", self.unified_termination);

   def winvarcreate(self):
      self.srcnamevar = tk.StringVar()
      self.destnamevar = tk.StringVar()
      self.forceckboxvar = IntVar()
      self.autoselvar = IntVar()
      self.showlessvar = IntVar()
      self.islessvar = IntVar()
      self.idpattnamevar = tk.StringVar()

   def wincreate(self):
      self.geometry("900x1000")
      row = 0
      self.wm_title("msmove")
#self.grid_columnconfigure(tuple(range(6)), weight=1)
      self.grid_columnconfigure(1, weight=1)
      self.grid_rowconfigure(0, weight=1)

      self.pdfp = pdfpreview(self)
      self.pdfp.grid(row=row,column=0,columnspan=5,sticky='nsew')
      row = row + 1
      self.sep1 = ttk.Separator(self,orient=tk.HORIZONTAL)
      self.sep1.grid(row=row, column=0, columnspan=5, sticky='ew')
      row = row + 1
      self.srclabel = Label(self, text="source:")
      self.srclabel.grid(row=row, column= 0, sticky=E)
      self.srcname = Label(self, width=40, textvar=self.srcnamevar)
      self.srcname.grid(row=row, column=1, columnspan=2, sticky=W)

#Page control frame
      pgcontframe = ttk.Frame(self)
      style = ttk.Style()
      style.layout(
            'Left2.TButton',[
                ('Button.focus', {'children': [
                    ('Button.leftarrow', None),
                    ('Button.padding', {'sticky': 'nswe', 'children': [
                        ('Button.label', {'sticky': 'nswe'}
                         )]}
                     )]}
                 )]
            )
      style.layout(
            'Right2.TButton',[
                ('Button.focus', {'children': [
                    ('Button.rightarrow', None),
                    ('Button.padding', {'sticky': 'nswe', 'children': [
                        ('Button.label', {'sticky': 'nswe'}
                         )]}
                     )]}
                 )]
            )

      style.configure('Left2.TButton',font=('','8','bold'), width=1, arrowcolor='black',command=self.pageminus)
      style.configure('Right2.TButton',font=('','8','bold'), width=1, arrowcolor='black',command=self.pageplus)
      self.lbutton2 = ttk.Button(pgcontframe, style='Left2.TButton',text='', command=self.pageminus)
      self.rbutton2 = ttk.Button(pgcontframe, style='Right2.TButton',text='', command=self.pageplus)
      self.lbutton2.grid(row=1,column=1)
      self.rbutton2.grid(row=1,column=3)
      self.curpgeLabel = Label(pgcontframe, text='0')
      self.cursepLabel = Label(pgcontframe, text='/')
      self.curtotLabel = Label(pgcontframe, text='0')
      self.curpgeLabel.grid(row=2, column=1)
      self.cursepLabel.grid(row=2, column=2)
      self.curtotLabel.grid(row=2, column=3)
      pgcontframe.grid(row=row, column=2, rowspan=2)

      self.deletebutton = Button(self, text="Delete",width=4,command=self.delete)
      self.deletebutton.grid(row=row,column=3)
      self.cancelbutton = Button(self, text="Exit",width=4,command=self.unified_termination)
      self.cancelbutton.grid(row=row,column=4)
      row = row + 1
      self.destlabel = Label(self, text="dest:")
      self.destlabel.grid(row=row, column= 0, sticky=E)
      self.destname = Entry(self, width=40, textvar=self.destnamevar)
      self.destname.grid(row=row, column=1, columnspan=2, sticky=W)
      self.dobutton = Button(self, text="Move",width=4,command=self.doit)
      self.dobutton.grid(row=row,column=3)
      self.skipbutton = Button(self, text="Skip",width=4,command=self.dontdoit)
      self.skipbutton.grid(row=row,column=4)
      row = row + 1
      self.sep1 = ttk.Separator(self,orient=tk.HORIZONTAL)
      self.sep1.grid(row=row, column=0, columnspan=5, sticky='ew')
      row = row + 1
      self.forcelabel = Label(self, text="force date:")
      self.forcelabel.grid(row=row, column= 0)
#TODO: look at calendar.dateentry to replace or add to these
      self.forcemonth = monthsel(self)
      self.forcemonth.grid(row=row, column = 1)
      self.forcemonth.bind('<<ComboboxSelected>>', self.forcedate)
      self.forceyear = yearsel(self)
      self.forceyear.grid(row=row, column = 2)
      self.forceyear.bind('<KeyRelease>', self.forcedate)
      self.forceckbox = ttk.Checkbutton(self, text='Use this as date', variable=self.forceckboxvar, command=self.forcedate)
      self.forceckbox.state(['!selected'])
      self.forceckbox.grid(row=row, column=3, columnspan=2)
      row = row + 1
      self.sep1 = ttk.Separator(self,orient=tk.HORIZONTAL)
      self.sep1.grid(row=row, column=0, columnspan=5, sticky='ew')
      row = row + 1
      self.srcdirlab = Label(self, text="source dir:")
      self.srcdirlab.grid(row=row, column=0)
      self.srcdirdis = Label(self, text=srcdir)
      self.srcdirdis.grid(row=row, column=1, columnspan=3, sticky=W)
      self.srcdirsel = Button(self, text="Sel",width=4,command=self.picsrcdir)
      self.srcdirsel.grid(row=row, column=4)
      row = row + 1
      self.sep1 = ttk.Separator(self,orient=tk.HORIZONTAL)
      self.sep1.grid(row=row, column=0, columnspan=5, sticky='ew')
      row = row + 1
      self.dstdirlab = Label(self, text="dest dirs:")
      self.dstdirlab.grid(row=row, column=0)
      self.dstdirdis = Label(self,width=40, text=self.destdirtree)
      self.dstdirdis.grid(row=row, column=1, columnspan=3, sticky=W)
      self.dstdirsel = Button(self, text="Sel",width=4,command=self.picdstdir)
      self.dstdirsel.grid(row=row, column=4)
      row = row + 1
      self.sep1 = ttk.Separator(self,orient=tk.HORIZONTAL)
      self.sep1.grid(row=row, column=0, columnspan=5, sticky='ew')
      row = row + 1
      self.autosel = ttk.Checkbutton(self,text='Auto select destination directory', variable = self.autoselvar, command=self.toggleauto)
      self.autosel.grid(row=row, column=1, columnspan=2, sticky='w')
      row = row + 1
      self.sep1 = ttk.Separator(self,orient=tk.HORIZONTAL)
      self.sep1.grid(row=row, column=0, columnspan=5, sticky='ew')
      row = row + 1
      self.showless = ttk.Checkbutton(self,text='Show less used', variable = self.showlessvar, command=self.showlessused)
      self.showless.grid(row=row, column=1,columnspan=2, sticky='w')
      self.isless = ttk.Checkbutton(self,text='Entry is less used', variable= self.islessvar, command=self.lessusedclick)
      self.isless.state(['!selected'])
      self.isless.grid(row=row, column=3,columnspan=2, sticky='w')
      row = row + 1
#      self.sep2 = ttk.Separator(self,orient=tk.HORIZONTAL)
#      self.sep2.grid(row=row, column=0, columnspan=5, sticky='ew')
#      row = row + 1
      self.idpattlabel = Label(self, text="id pattern:", anchor='e')
      self.idpattlabel.grid(row=row, column= 0, sticky=E)
      self.idpattname = Entry(self, width=45, textvar=self.idpattnamevar)
      self.idpattname.grid(row=row, column=1, columnspan=4, sticky=W)
      self.idbutton = Button(self, text="Get",width=4,command=self.usermodidget)
      self.idbutton.grid(row=row,column=4)
      row = row + 1
      self.pattlabel = Label(self, text="rename pattern:", anchor='e')
      self.pattlabel.grid(row=row, column= 0, sticky=E)
      self.pattname = Entry(self, width=45, textvar=self.pattnamevar)
      self.pattname.bind('<KeyRelease>', self.forcedate)
      self.pattname.grid(row=row, column=1, columnspan=4, sticky=W)
      self.pattbutton = Button(self, text="Save",width=4,command=self.usermodidpat)
      self.pattbutton.grid(row=row,column=4)
      row = row + 1
#      self.grid_rowconfigure(row,weight=1)
      self.dirlist=dirlistpanel(self, self.config)
      self.dirlist.grid(row=row,column=0,columnspan=5,sticky='nsew')

#worklist routines.  TODO: make a class for this.
   def addtoworklist(self, n):
      with self.worklock: #possible contention in onmove event
         self.worklist.append(n)
         if self.worklistpos == 0:
            self.worklistpos = 1  #from empty to one entry
            self.setworklistposdisplay()
            self.loadworkfile()
         self.setworklistsizedisplay()

   def delcurfromworklist(self):
      with self.worklock: #possible contention in onmove event
         del self.worklist[self.worklistpos-1]  #position is index plus 1
         if self.worklistpos > len(self.worklist):
            self.worklistpos = self.worklistpos - 1
            self.setworklistposdisplay()
         self.setworklistsizedisplay()

   def pageminus(self):
      if self.worklistpos > 1:
         self.worklistpos = self.worklistpos - 1
         self.setworklistposdisplay()
         self.loadworkfile()

   def pageplus(self):
      if self.worklistpos < len(self.worklist):
         self.worklistpos = self.worklistpos + 1
         self.setworklistposdisplay()
         self.loadworkfile()

   def setworklistposdisplay(self):
      self.curpgeLabel.config(text = self.worklistpos)

   def setworklistsizedisplay(self):
      self.curtotLabel.config(text = str(len(self.worklist)))

   def currentwork(self):
      if self.worklistpos > 0:
         return self.worklist[self.worklistpos - 1]
      else:
         return ''

   def ismorework(self):
      if self.worklistpos > 0:
         return True
      else:
         return False

#end of worklist routines


   def config_save(self):
      self.config.setsourcedir(self.srcdir)
      self.config.setdestdir(self.destdirtree)
      self.config.setshowless(self.showlessvar.get())

   def config_get(self):
      self.showlessvar.set(self.config.getshowless())
      self.srcdir = self.config.getsourcedir()
      self.destdirtree = self.config.getdestdir()


      #This makes tk responsive to control-C from launching terminal
   def check(self):
      self.after(500,self.check)

   def run(self):
      self.observer_start()
      self.winvarcreate() #all the window variables
      self.config_get()
      self.wincreate()
      self.setdirlist()
      self.lift() #maybe
      self.attributes('-topmost', True) #maybe
      self.check()
      self.mainloop()

   def usermodidget(self):
      #get source filename for prototype id
      self.idpattnamevar.set(self.srcnamevar.get())

   def usermodidpat(self):
      #save id pattern back to file and update dest name and scores
      self.updatepatternfromuser()
      self.config.writeconfig()
#      self.setdestfilename()
#      if self.showlessvar.get() == 0:
#         self.dirlist.displaytopdir()
#TODO: save this to the data file

   def showlessused(self):
      self.dirlist.displaytopdir()
      self.config_save()

   def toggleauto(self):
      print('auto')

   def lessusedclick(self):
#      d = self.dirlist.getselecteddir()
      self.dirlist.setselectedlessused(self.islessvar.get())
#self.updatepatternfromuser() #TODO maybe make this more targeted
#TODO; set config entry and redraw the list if this was  undone
#      if self.showlessvar.get() == 0: 
#         self.dirlist.displaytopdir()  #disappear the now less used dir

   def setdirlist(self):
      self.dirlist.settopdir(self.destdirtree)

   def userdirselection(self, idpattern,renamepattern):
      if len(self.destnamevar.get()) > 0:
         self.setdestfilename()

   def observer_start(self):
      self.observer = watchdog.observers.Observer()
      event_handler = eventhandle()
      event_handler.setclass(self)
      self.observer.schedule(event_handler, self.srcdir, recursive = False)
      self.observer.start()

       #called to stop observer when exiting
   def observer_end(self):
      self.observer.stop()
      self.observer.join()

   def picsrcdir(self):
      newdir = filedialog.askdirectory()
      if len(newdir) > 0:
         self.config.setsourcedir(newdir)
         self.srcdirdis.config(text=newdir)

   def picdstdir(self):
      newdir = filedialog.askdirectory()
      if len(newdir) > 0:
         self.config.setdestdir(newdir)
         self.dstdirdis.config(text=newdir)
         self.dirlist.settopdir(newdir)

#Button controls for source file.  Delete, Move, Skip

   def dontdoit(self):
           #get next file or wait
      #print("dont")
         #clear source
      self.clearfile()

   def moveitthread(self, src, dst):
      shutil.move(src, dst)

   def domove(self):
         #get dest dir
         #dest = self.dirlist.getselecteddir()
         #set dest name
         #execute copy from current name to destdir/destname
      t = threading.Thread(target=self.moveitthread, args=(self.currentwork(), self.destnamevar.get()))
      t.start()
      #print("process ",self.destnamevar.get(), ' ', self.currentwork())
         #clear source
      self.clearfile()

   def delete(self): 
      ans = messagebox.askyesno(title='Confirm Delete', message = 'Really Delete?')
      if ans == True:
         pathlib.Path.unlink(self.currentwork())
         self.dontdoit()

#called when move button hit
   def doit(self):
      dest = self.destnamevar.get()
      if os.path.exists(dest):
         ans = messagebox.askyesno(title='Dest Conflict', message = 'Destination exists.  Overwrite?')

         if ans == True:
            self.domove()
             #create warning, and check if we want to overwrite
      else:
         self.domove()

#END of Button controls
      

#TODO: fix this so that it doesn't reset the displayed selected directory
   def updatepatternfromuser(self):
      idpat = self.idpattnamevar.get()
      self.dirlist.setselectedidpat(idpat)
      modpat = self.pattnamevar.get()
      self.dirlist.setselectedrenamepat(modpat)
      lessused = self.islessvar.get()
      self.dirlist.setselectedlessused(lessused)

   def setpatterndisplay(self):
      idpat = self.dirlist.getselectedidpat()
      self.idpattnamevar.set(idpat)
      destpat = self.dirlist.getselectedrenamepat()
      self.pattnamevar.set(destpat)
      destused = self.dirlist.getselectedlessused()
      self.islessvar.set(destused)
      self.setdestfilename()

   def srcnamebase(self):
      f = self.srcnamevar.get()
      fname, fext = os.path.splitext(f)
      return fname

   def srcnameext(self):
      f = self.srcnamevar.get()
      fname, fext = os.path.splitext(f)
      return fext

    #callback when key is released in Entry
   def forcedate(*args):
      self = args[0]
      self.setdestfilename()


#TODO: carry filename extension (.pdf usually)
    #entry to update of name that won't pull the selected pattern. for edits.
   def setdestfilename(self):
#destpat = self.dirlist.getselectedrenamepat()
      destpat = self.pattnamevar.get()
      if len(destpat) > 0:
         if '%f' in destpat:
            destpat = destpat.replace('%f', self.srcnamebase())
         destdir = self.dirlist.getselecteddir()
         fullpathpat = os.path.join(destdir, destpat)
         if self.forceckboxvar.get() == 1:
            years = self.forceyear.get()
            years = ''.join(filter(str.isdigit, years))
            if len(years) != 4:
               return   #probably editing the year
            year = int(years)
            month = self.forcemonth.current() + 1  #zero based
            ymd = "%4d%.2d01" % (year, month)
#time = datetime.datetime.fromisoformat('yyyymmdd')
            time = datetime.datetime.fromisoformat(ymd)
         else:
            time = datetime.datetime.now()
         self.destfilename = time.strftime(fullpathpat) + self.srcnameext()
#      self.destname.delete(0, END)
#      self.destname.insert(0, self.destfilename)
         self.destnamevar.set(self.destfilename)
         self.destname.xview_moveto(1)
      else:
         self.destfilename = ''
         self.destnamevar.set(self.destfilename)

   def clearfile(self):
      self.srcnamevar.set("")
      self.delcurfromworklist()
      self.pdfp.clear()
      self.setdestfilename() #reset from pattern
           #get next file or wait
      self.loadworkfile()

   def loadworkfile(self): #eventually use selected index in array
         f = self.currentwork()
         self.srcnamevar.set(os.path.basename(f))
         self.pdfp.setfile(f)
         self.setdestfilename()

   def unified_termination(self):
#if one wants to ask if they are sure about exiting, then 
#checking self.work.empty() and also whether we are displaying a file
#TODO: Change to check that worklist is empty
      if self.ismorework() == True:
         ans = messagebox.askyesno(title='Exit with work', message = 'Work remains, really exit?')
         if ans == False:
            return
      self.endqueue = True
      self.observer_end()
#only from version 3.13   self.work.shutdown(immediate=True)
      self.destroy()

   def finishwin(self):
      self.destroy()

   def finishup(self):
      self.endqueue = True
      self.observer_end()
      work.put("")  #wake up the get so thread can exit

   def destroywin(self):
      self.finishup()
      self.destroy()

   def guessbest(self):
      print('guessing')


class monthsel(ttk.Combobox):
   def __init__(self, s):
      super().__init__(s,width=8)
      self['values'] = [month_name[m][0:3]+' ('+str(m)+')' for m in range(1, 13)]
      self.current(newindex=datetime.datetime.now().month-1)

class yearsel(Entry):
   def __init__(self, s):
      self.yearvar = tk.StringVar()
      super().__init__(s,textvar = self.yearvar, width=6)
      self.yearvar.set(str(datetime.datetime.now().year))

class pdfpreview(Frame):
   def __init__(self, c):
      super().__init__(c)
      self.grid_rowconfigure(0,weight=1)
      self.grid_columnconfigure(0,weight=1)
      self.canvas = Canvas(self)
      self.canvas.grid(row=0,column=0,sticky='nsew')
      self.vscroll = ttk.Scrollbar(self,orient=tk.VERTICAL,command=self.canvas.yview)
      self.canvas['yscrollcommand'] = self.vscroll.set
      self.vscroll.grid(row=0,column=1,sticky='ns')
      self.clear()
      self.canvas.bind("<MouseWheel>", on_mousewheel)
      self.canvas.bind("<Button-4>", lambda event: self.canvas.yview_scroll(-1, "units"))
      self.canvas.bind("<Button-5>", lambda event: self.canvas.yview_scroll(1, "units"))
      self.canvas.bind("<Configure>", self.resize_canvas)

   def clear(self):
      self.canvas.delete('all')
      self.doc = None
      self.images=[]
      self.pageimages=[]

   def setfile(self,f):
      self.clear()
      self.doc = fitz.open(f)
      self.pageimages=[]
      for p in self.doc:
         pix = p.get_pixmap()
         self.pageimages.append(PIL.Image.open(io.BytesIO(pix.pil_tobytes('ppm'))))
      self.images = [] #clear this
      self.setpages(self.canvas.winfo_width(), self.canvas.winfo_height())

   def setpages(self, w, h):
      ypos = 0
      self.pages=[]
      for im1 in self.pageimages:
         ih = im1.height 
         iw = im1.width
         nw = w      #new width
         ratio = nw/iw
         nh = int(ratio * ih)
         im2 = im1.resize((nw,nh))
         buf = io.BytesIO()
         im2.save(buf, format='PPM')
         self.pages.append(PhotoImage(data=buf.getvalue()))
         ypos = ypos + nh
      ypos = 0
      if len(self.images) > 0:
         for i in range(len(self.images)):
            self.canvas.itemconfig(self.images[i],image=self.pages[i])
            self.canvas.moveto(self.images[i],0, ypos)
            ypos = ypos + self.pages[i].height()
      else:
         for p in self.pages:
            ih = p.height()
            self.images.append(self.canvas.create_image((0,ypos),anchor=NW,image=p))
            ypos = ypos + ih
      self.canvas.config(width=w,height=h,scrollregion=(0,0,w,ypos))

   def resize_canvas(self, e):
      self.setpages(e.width-2, e.height-2) #-2 for border

class dirlistpanel(Frame):
   def __init__(self, c, config):
      super().__init__(c)
      self.select_cb = c  
      self.config = config
      self.listvar = Variable()
      self.grid_rowconfigure(0,weight=1)
      self.grid_columnconfigure(0,weight=1)
      self.list = Listbox(self, height=10, listvariable=self.listvar, exportselection=False)
      self.list.grid(row=0,column=0,sticky='nsew')
      self.vscroll = ttk.Scrollbar(self,orient=tk.VERTICAL,command=self.list.yview)
      self.list['yscrollcommand'] = self.vscroll.set
      self.vscroll.grid(row=0,column=1,sticky='ns')
      self.list.bind('<<ListboxSelect>>', self.userselect)
      self.list.bind("<MouseWheel>", on_mousewheel)

   def settopdir(self, topdir):
      self.topdir = topdir
      self.getsubdirs()
      self.displaytopdir()
#TODO is this really necessary?
      self.select_cb.setpatterndisplay()

   def getsubdirs(self):
      subfolders = []
      if os.path.isdir(self.topdir):
         for root, dirs, files in os.walk(self.topdir):
            for d in dirs:
               subfolders.append(os.path.join(root,d))
#old way: subfolders = [ f for f in os.scandir(self.topdir) if f.is_dir() and not f.name.startswith('.') ]
         self.sortedsubfolders = sorted(subfolders, key=lambda s: s.lower())
      else:
         self.sortedsubfolders = []

#TODO dirlist[] is set/cleared when directory changes not on redisplay
#dirlist[] maintains working data of diretory
#config is where long term storage happens... or is this the working storage?
   def displaytopdir(self):
      self.dirlist=[]
      self.displaylist = []
      self.list.delete(0, tk.END)
      showless = self.select_cb.showlessvar.get()
      topdirlen = len(self.select_cb.destdirtree) + 1
      for d in self.sortedsubfolders:
         (newname, pattern, lessused) = self.getinfo(d)
         if showless == 1 or lessused == 0:
            self.displaylist.append(d[topdirlen:])
            self.dirlist.append(d)
      self.listvar.set(self.displaylist)
      self.list.select_set(0)  #as if first row selected
      self.selectrow(0) #set up variables
#get info for directories

         #we are setting a row programmatically
   def selectrow(self, row):  #row 0 based
      if row < len(self.dirlist):
         full = os.path.join(self.topdir, self.dirlist[row])
         self.select_cb.setdestfilename()
#self.select_cb.userdirselection(self.dirlist[row].idpattern,self.dirlist[row].renamepattern)

#TODO fix getting info from existing
   def getinfo(self,d):
      full = os.path.join(self.topdir, d)
      (idpat, renpat, lu) = self.select_cb.config.getdirdat(full)
      return (idpat, renpat, lu)

             #user clicked on a row
   def userselect(self, event):
#TODO: if one of the patterns was changed but not saved ask user if sure
      s = self.list.curselection()
      if len(s) == 1:
         self.selectrow(s[0])
      self.select_cb.setpatterndisplay()

   def getselecteddir(self):
      row = self.list.curselection()[0] #single select mode, and we always have something selected.
      full = os.path.join(self.topdir, self.dirlist[row])
#      full = self.dirlist[row].path
      return full

   def getselectedidpat(self):
      s = self.list.curselection()
      if len(s) > 0:
         row = s[0] #single select mode, and we always have something selected.
         full = os.path.join(self.topdir, self.dirlist[row])
         pat = self.config.getdiridpat(full)
         return pat
      else:
         return ''

   def getselectedlessused(self):
      s = self.list.curselection()
      if len(s) > 0:
         row = s[0] #single select mode, and we always have something selected.
         full = os.path.join(self.topdir, self.dirlist[row])
         return self.config.getdirlu(full)
      else:
         return 0

    #get the rename pattern from the Entry box
   def getselectedrenamepat(self):
      s = self.list.curselection()
      if len(s) > 0:
         row = s[0] #single select mode, and we always have something selected.
         full = os.path.join(self.topdir, self.dirlist[row])
         pat = self.config.getdirrenpat(full)
         if len(pat) == 0:
            pat = DEFAULTRENAME
   #      full = os.path.join(self.dirlist[row].path, pat)
         return pat
      else:
         return ''

   def setselectedrenamepat(self, newpat):
      s = self.list.curselection()
      if len(s) > 0:
         row = s[0]
         full = os.path.join(self.topdir, self.dirlist[row])
         self.config.setdirrenpat(full, newpat)
   
   def setselectedidpat(self, newpat):
      s = self.list.curselection()
      if len(s) > 0:
         row = s[0]
         full = os.path.join(self.topdir, self.dirlist[row])
         self.config.setdiridpat(full, newpat)
   
   def setselectedlessused(self, lessused):
      s = self.list.curselection()
      if len(s) > 0:
         row = s[0]
         full = os.path.join(self.topdir, self.dirlist[row])
         self.config.setdirlu(full, lessused)
#self.select_cb.config.setdirlu(self.getselecteddir(), lessused)
         showless = self.select_cb.showlessvar.get()
         if showless == 0:  #redisplay if this one gets undisplayed
            self.displaytopdir()
      
class destdir():
   def __init__(self, path, idpattern, newname, lessused):
      self.path = path
      self.idpattern = idpattern
      self.renamepattern = newname
      self.lessused = lessused

class eventhandle(watchdog.events.FileSystemEventHandler):
   work = None
   def setclass(self, c):
      self.ourclass = c

     #when a desired file is moved, put it on the work queue
   def on_moved(self, event):
          #this is the move after the browser finishes download
      dest = event.dest_path
      lowerdest = dest.lower()
      for ext in INTERESTINGEXTENSIONS:
         if lowerdest.endswith(ext):
#            self.work.put(dest)
            self.ourclass.addtoworklist(dest)
            break

class sighandle():
   win = None

   def setwin(self,window):
      self.win = window

   def sigint_handler(self, sig, frame):
      self.win.unified_termination()
#      self.win.finishup()
#      self.win.finishwin()

#config file: ~/.config/msmove or if no .config, ~/.msmove
#format: json
#program
#  hide dirs
#directories
# name a
#  lessused: false
#  newname: prototype
#  pattern: match pattern
# name b
#  lessused: false
#  newname: prototype
#  pattern: match pattern
class configfile():
   def __init__(self):
      self.loadconfig()

   def proginfo(self):
      print(self.confdat['program'])

   def loadconfig(self):
      self.confdat = None
      confdir = os.path.expanduser('~/.config')
      if os.path.exists(confdir):
         self.configfile = os.path.expanduser('~/.config/msmove')
      else:
         self.configfile = os.path.expanduser('~/.msmove')
      if os.path.exists(self.configfile):
         with open(self.configfile) as f:
            self.confdat = yaml.safe_load(f)
         of = self.configfile + '.orig'
         if os.path.exists(of):
            os.remove(of)
      if self.confdat == None:
         self.confdat = {}
      if 'dirinfo' not in self.confdat:
         self.confdat['dirinfo'] = []
      if 'program' not in self.confdat:
         self.confdat['program'] = {}
         self.confdat['program']['showless'] = '0'
         self.confdat['program']['sourcedir'] = '~/Downloads'
         self.confdat['program']['destdir']='~/statements'
#TODO These should reflect command line arguments
      for r in self.confdat:
         if 'lu' in r:
            print(r['lu'])
   def writeconfig(self):
      of = self.configfile + '.orig'
      if not os.path.exists(of):
         if os.path.exists(self.configfile):
            os.rename(self.configfile, of) #save original until next time
      else:
         bak = self.configfile + '.bak'
         if os.path.exists(bak):
            os.remove(bak)
            if os.path.exists(self.configfile):
               os.rename(self.configfile, bak)
      with open(self.configfile,'w') as f:
         self.cleanconfdat()
         yaml.dump(self.confdat, f)
   def getdirdat(self, d):
      for dat in self.confdat['dirinfo']:
         if dat['dir'] == d:
#print (dat['idpat'], dat['renpat'], dat['lu'])
            return (dat['idpat'], dat['renpat'], dat['lu'])
      return ('','',0)
   def setdirdat(self, d, idpat, renpat, lu):
      for dat in self.confdat['dirinfo']:
         if dat['dir'] == d:
            dat['renpat'] = renpat
            dat['idpat'] = idpat
            dat['lu'] = lu
            self.writeconfig()
            return 
      self.confdat['dirinfo'].append({'dir':d,'lu':lu,'renpat':renpat,'idpat':idpat})
      self.writeconfig()
      return 
   def getdirrenpat(self,d):
      for dat in self.confdat['dirinfo']:
         if dat['dir'] == d:
            return dat['renpat']
      return ''

   def setdirrenpat(self,d,renpat):
      for dat in self.confdat['dirinfo']:
         if dat['dir'] == d:
            dat['renpat'] = renpat
            self.writeconfig()
            return
      self.confdat['dirinfo'].append({'dir':d,'lu':'','renpat':renpat,'idpat':''})
      self.writeconfig()

   def getdiridpat(self,d):
      for dat in self.confdat['dirinfo']:
         if dat['dir'] == d:
            return dat['idpat']
      return ''

   def setdiridpat(self,d,idpat):
      for dat in self.confdat['dirinfo']:
         if dat['dir'] == d:
            dat['idpat'] = idpat
            self.writeconfig()
            return
      self.confdat['dirinfo'].append({'dir':d,'lu':'','renpat':'','idpat':idpat})
      self.writeconfig()

   def getdirlu(self,d):
      for dat in self.confdat['dirinfo']:
         if dat['dir'] == d:
            return dat['lu']
      return 0

   def setdirlu(self,d,lu):
      for dat in self.confdat['dirinfo']:
         if dat['dir'] == d:
            dat['lu'] = lu
            self.writeconfig()
            return
      self.confdat['dirinfo'].append({'dir':d,'lu':lu,'renpat':'','idpat':''})
      self.writeconfig()

   def cleanconfdat(self):
      for dat in self.confdat['dirinfo']:
         if len(dat['idpat']) == 0 and len(dat['renpat']) == 0 and dat['lu'] == 0:
            self.confdat['dirinfo'].remove(dat)
   def setdirpat(self,d,pat):
      for dat in self.confdat['dirinfo']:
         if dat['dir'] == d:
            dat['renpat'] = pat
            self.writeconfig()
            return
      self.confdat['dirinfo'].append({'dir':d,'lu':0,'renpat':pat,'idpat':''})
      self.writeconfig()
   def setsourcedir(self,d):
      self.confdat['program']['sourcedir'] = d
      self.writeconfig()
   def getsourcedir(self):
      return self.confdat['program']['sourcedir']
   def setdestdir(self,d):
      self.confdat['program']['destdir'] = d
      self.writeconfig()
   def getdestdir(self):
      return self.confdat['program']['destdir']
   def setshowless(self,d):
      self.confdat['program']['showless'] = d
      self.writeconfig()
   def getshowless(self):
      return self.confdat['program']['showless']

def on_mousewheel(event):
   # Determine which widget is currently under the mouse
   target_widget = event.widget
   # Scroll the specific widget
   if target_widget.winfo_class() == 'Canvas':
      # For Windows/macOS, event.delta gives a value (e.g., 120 or -120)
      # For X11, event.num can be 4 or 5
      if event.num == 4:
         # Scroll up for X11 systems
         target_widget.yview_scroll(-1, "units")
      elif event.num == 5:
         # Scroll down for X11 systems
         target_widget.yview_scroll(1, "units")
      else:
         # For Windows/macOS
         target_widget.yview_scroll(int(-1*(event.delta/120)), "units")

def arguments(config):
   p = argparse.ArgumentParser(description="move monthly statements")
   p.add_argument('srcdir', nargs='?', default = config.getsourcedir())
   p.add_argument('destdirtree', nargs='?', default=config.getdestdir())
   args = p.parse_args();
   return(os.path.expanduser(args.srcdir), os.path.expanduser(args.destdirtree))

icon64 = """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"""

if __name__ == '__main__':
   global win
        #process command line arguments
   config = configfile()
   (srcdir, destdirtree) = arguments(config)
   work = queue.Queue()
   sig = sighandle()
   signal.signal(signal.SIGINT, sig.sigint_handler)
   win = window(work,srcdir,destdirtree, config)
   sig.setwin(win)
   win.run()
   win.finishup()
   config.writeconfig()
